<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini Pac‑Man — HTML/CSS/JS</title>
<style>
  :root{--bg:#000; --wall:#0a3; --pac:#ffcc00; --dot:#ffd; --ghost:#ff4f4f}
  *{box-sizing:border-box}
  body{margin:0;display:flex;align-items:center;justify-content:center;height:100vh;background:linear-gradient(#001,#000);font-family:system-ui,Arial}
  .board{background:#001a00;padding:16px;border-radius:12px;box-shadow:0 20px 50px rgba(0,0,0,.7);}
  canvas{display:block;background:var(--bg);image-rendering:pixelated;border-radius:6px}
  .hud{color:#fff;margin-top:8px;text-align:center}
  .small{font-size:13px;color:#ddd}
</style>
</head>
<body>
  <div class="board">
    <canvas id="c" width="420" height="420" aria-label="Pac-Man game"></canvas>
    <div class="hud">Score: <span id="score">0</span> — Lives: <span id="lives">3</span></div>
    <div class="hud small">Use ← ↑ → ↓ keys to move. Eat all dots. Avoid ghost.</div>
  </div>

<script>
// --- Mini Pac-Man (single file) ---
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const livesEl = document.getElementById('lives');

const TILE = 20;            // tile pixel size
const COLS = 21;            // should match map width
const ROWS = 21;

// Simple map: 0 = dot, 1 = wall, 2 = empty (no dot)
// Layout is 21x21
const MAP = [
  "111111111111111111111",
  "100000001000000001001",
  "101110101011101011101",
  "101110101011101011101",
  "100000000000000000001",
  "101110111111111011101",
  "100010100000001010001",
  "111010101111101010111",
  "000000001000000000000",
  "111010101011101010111",
  "100010100000001010001",
  "101110111111111011101",
  "100000000000000000001",
  "101110101011101011101",
  "101110101011101011101",
  "100000001000000001001",
  "111111111111111111111",
  "000000000000000000000",
  "111111111111111111111",
  "000000000000000000000",
  "111111111111111111111"
];

let grid = []; // each cell: {wall:boolean, dot:boolean}
let totalDots = 0;

function initGrid(){
  grid = [];
  totalDots = 0;
  for(let y=0;y<ROWS;y++){
    const row = [];
    const line = MAP[y] || "".padEnd(COLS,'1');
    for(let x=0;x<COLS;x++){
      const ch = line[x] || '1';
      const wall = ch === '1';
      const dot = !wall && !(y===9 && x===10) && !(y===9 && x===9) && !(y===9 && x===11); // avoid placing dot in spawn area
      if(dot) totalDots++;
      row.push({wall,dot});
    }
    grid.push(row);
  }
}

// Player state
let pac = {x:10,y:15,dir:{x:0,y:0},nextDir:{x:0,y:0}};
let score = 0, lives = 3, gameOver=false;

// Ghost state (single ghost chasing pac-man)
let ghost = {x:10,y:7,dir:{x:0,y:1}, mode:'chase', cooldown:0};

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // background
  ctx.fillStyle = '#001';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // draw walls and dots
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      const cell = grid[y][x];
      const px = x*TILE, py = y*TILE;
      if(cell.wall){
        // wall block with simple rounded look
        ctx.fillStyle = '#004400';
        ctx.fillRect(px+2,py+2,TILE-4,TILE-4);
      } else if(cell.dot){
        ctx.fillStyle = '#ffd';
        ctx.beginPath(); ctx.arc(px+TILE/2, py+TILE/2, 2.5, 0, Math.PI*2); ctx.fill();
      }
    }
  }

  // draw pac (simple circle with mouth)
  const pacPx = pac.x*TILE + TILE/2;
  const pacPy = pac.y*TILE + TILE/2;
  const angle = Math.atan2(pac.dir.y || -1, pac.dir.x || 1);
  ctx.fillStyle = '#ffcc00';
  const mouth = Math.PI/4;
  ctx.beginPath();
  ctx.moveTo(pacPx,pacPy);
  ctx.arc(pacPx,pacPy, TILE/2 - 2, angle + mouth, angle - mouth, true);
  ctx.closePath(); ctx.fill();

  // draw ghost
  const gPx = ghost.x*TILE; const gPy = ghost.y*TILE;
  ctx.fillStyle = '#ff4f4f';
  ctx.beginPath(); ctx.arc(gPx+TILE/2, gPy+TILE/2 - 2, TILE/2 - 2, Math.PI, 0); ctx.fill();
  // ghost feet
  ctx.fillRect(gPx+2, gPy+TILE/2, TILE-4, TILE/2);

  // eyes
  ctx.fillStyle = '#fff'; ctx.fillRect(gPx+TILE/3, gPy+TILE/4, 4, 6); ctx.fillRect(gPx+TILE*2/3-4, gPy+TILE/4, 4, 6);
  ctx.fillStyle = '#00f'; ctx.fillRect(gPx+TILE/3+1, gPy+TILE/4+1, 2, 4); ctx.fillRect(gPx+TILE*2/3-3, gPy+TILE/4+1, 2, 4);
}

function canMove(x,y){
  if(x<0||y<0||x>=COLS||y>=ROWS) return false;
  return !grid[y][x].wall;
}

function step(){
  if(gameOver) return;
  // apply nextDir if possible
  if(pac.nextDir.x!==0 || pac.nextDir.y!==0){
    const nx = pac.x + pac.nextDir.x, ny = pac.y + pac.nextDir.y;
    if(canMove(nx,ny)) pac.dir = {...pac.nextDir};
  }
  // move pac
  const tx = pac.x + pac.dir.x, ty = pac.y + pac.dir.y;
  if(canMove(tx,ty)) { pac.x = tx; pac.y = ty; }

  // eat dot
  const cell = grid[pac.y][pac.x];
  if(cell.dot){ cell.dot=false; score+=10; totalDots--; scoreEl.textContent = score; }

  // ghost simple chase: choose move that minimises manhattan distance and not backwards
  if(ghost.cooldown>0) ghost.cooldown--;
  if(ghost.cooldown===0){
    const head = {x:pac.x,y:pac.y};
    let best = null; let bestD = 1e9;
    const possible = [ {x:ghost.x+1,y:ghost.y,dx:1,dy:0}, {x:ghost.x-1,y:ghost.y,dx:-1,dy:0}, {x:ghost.x, y:ghost.y+1,dx:0,dy:1}, {x:ghost.x, y:ghost.y-1,dx:0,dy:-1}];
    for(const p of possible){
      if(!canMove(p.x,p.y)) continue;
      // prevent immediate reverse (make ghost less jittery)
      if(p.dx === -ghost.dir.x && p.dy === -ghost.dir.y) continue;
      const d = Math.abs(p.x-head.x) + Math.abs(p.y-head.y);
      if(d < bestD){ bestD = d; best = p; }
    }
    if(best){ ghost.dir.x = best.dx; ghost.dir.y = best.dy; }
    ghost.cooldown = 0; // can change every frame; alter to slow
  }
  ghost.x += ghost.dir.x; ghost.y += ghost.dir.y;
  // wrap edges
  if(ghost.x<0) ghost.x = COLS-1; if(ghost.x>=COLS) ghost.x=0; if(ghost.y<0) ghost.y=ROWS-1; if(ghost.y>=ROWS) ghost.y=0;

  // collision
  if(pac.x===ghost.x && pac.y===ghost.y){
    lives--; livesEl.textContent = lives;
    if(lives<=0){ gameOver=true; alert('Game Over — Score: '+score); return; }
    // respawn positions
    pac.x=10; pac.y=15; pac.dir={x:0,y:0}; pac.nextDir={x:0,y:0};
    ghost.x=10; ghost.y=7; ghost.dir={x:0,y:1};
  }

  // win condition
  if(totalDots<=0){ alert('You win! Score: '+score); gameOver=true; }

  draw();
}

// controls
window.addEventListener('keydown', e=>{
  if(e.key==='ArrowLeft'){ pac.nextDir={x:-1,y:0}; }
  else if(e.key==='ArrowRight'){ pac.nextDir={x:1,y:0}; }
  else if(e.key==='ArrowUp'){ pac.nextDir={x:0,y:-1}; }
  else if(e.key==='ArrowDown'){ pac.nextDir={x:0,y:1}; }
});

// init
initGrid(); draw();
setInterval(step, 250);
</script>
</body>
</html>
